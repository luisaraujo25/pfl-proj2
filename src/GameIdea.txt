play_game:-
    initial_state(Board), --> Iniciar a Board
    display_game(Board),
    game_cycle(Board, Color).

game_cycle(Board, Color):-
    game_over(GameState, Winner), !,
    congratulate(Winner).
    
game_cycle(Board, Color):-
    choose_move(GameState, Player, Move),
    move(GameState, Move, NewGameState),
    next_player(Player, NextPlayer),
    display_game(GameState-NextPlayer), !,
    game_cycle(NewGameState-NextPlayer).

choose_move(Board, Color, Move):-
    % interaction to select move

choose_move(GameState, computer-Level, Move):-
    valid_moves(GameState, Moves),
    choose_move(Level, GameState, Moves, Move).

valid_moves(GameState, Moves):-
    findall(Move, move(GameState, Move, NewState), Moves).
      choose_move(1, _GameState, Moves, Move):-
    random_select(Move, Moves, _Rest).

choose_move(2, GameState, Moves, Move):-
    setof(Value-Mv, NewState^( member(Mv, Moves),
    move(GameState, Mv, NewState),
    evaluate_board(NewState, Value) ), [_V-Move|_]).

vacant(X, Y, Board) :-
  between(1, 8, X),
  between(1, 8, Y),
  \+(member(piece(_, X, Y), Board)).

possible_move(Board, Color, End) :-
  select(piece(Color, X, Y), Board, Motion),
  (
    N_X is X + 1, N_Y is Y + 2;
    N_X is X - 1, N_Y is Y + 2;
    N_X is X + 1, N_Y is Y - 2;
    N_X is X - 1, N_Y is Y - 2;
    N_X is X + 2, N_Y is Y + 1;
    N_X is X - 2, N_Y is Y + 1;
    N_X is X + 2, N_Y is Y - 1;
    N_X is X - 2, N_Y is Y - 1
  ),
  (
    vacant(N_X, N_Y, Board),
    place(piece(Color, N_X, N_Y), Motion, End)
    ;
    capture(piece(Color, knight, N_X, N_Y), Motion, End)
    % not valid move?
  ).

move(A, Player, B) :-
  possible_move(A, Player, B),
  opponent(Player, Other),
  \+(
    possible_move(B, Other, C),
    \+(member(piece(Player, king, _, _), C))).  % Was for chess
    %checking if the player isnt checkmating himself???